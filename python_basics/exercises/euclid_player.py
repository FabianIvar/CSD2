# timestamp_dict_player combined with all other code

from pygame import mixer
import time
from list_transform import rotate
import random
import inp_v2 as inp
import numpy as np
from inp_v2 import validateType as check

#settings function with user input certain values need to be constrained TODO:

def settings(**set):

    """Returns global_settings and sample_settings stored in a dictionary

    Parameter set['file_name']: The name of the sample to configure and return settings of
    Parameter set['type']: The type of setting to configure and return
            Options: "global", "sample"""


    match set['type']:

        case 'global':
            global_config = {
                "num_layers": max(check(input("Number of layers (1-4): "),'int'), 1),
                "num_pulses": max(check(input("Number of pulses: "),'int'),1),
                "bpm": inp.constrain(check(input("Beats per minute: "),'int'), 10, 512),
                "state": 'configured'}
            return global_config

        case 'sample':
            if global_settings['state'] != 'configured':
                print("global settings are not yet configured")
            else:
                sample_config = {
                    "sample": set['file_name'] + '.wav',
                    "num_pulses": global_settings['num_pulses'],
                    "num_notes": check(input("Number of notes: "),'int'),
                    "volume": inp.constrain(check(input("Gain (value between 0-1): "),'float'), 0, 1),
                    "rotation_amt": check(input("amt to rotate: "),'int')}
                sample_config.update({'num_notes': inp.constrain(sample_config['num_notes'], 0, global_settings['num_pulses'])})
                return sample_config

"""def settings(**set): # temp

    #Returns global_settings and sample_settings stored in a dictionary

    #Parameter set['file_name']: The name of the sample to configure and return settings of
    #Parameter set['type']: The type of setting to configure and return
            Options: "global", "sample"


    match set['type']:

        case 'global':
            global_config = {
                "num_layers": inp.constrain(check(4,'int'), 0, 4),
                "num_pulses": check(random.randint(10,25),'int'),  # cant be zero because division by zero
                "bpm": inp.constrain(check(120,'int'), 0, 512),
                "state": 'configured'}
            return global_config

        case 'sample':
            if global_settings['state'] != 'configured':
                print("global settings are not yet configured")
            else:
                sample_config = {
                    "sample": set['file_name'] + '.wav',
                    "num_pulses": global_settings['num_pulses'],
                    "num_notes": check(random.randint(1,15),'int'), #can't be 0 because division by zero
                    "volume": inp.constrain(check(1,'float'), 0, 1),
                    "rotation_amt": check(random.randint(1,10),'int')}
                sample_config.update({'num_notes': inp.constrain(sample_config['num_notes'], 0, global_settings['num_pulses'])})
                return sample_config"""

def pack_sample_settings():
    """Starts sample settings configuration and saves the settings of each sample in nested dictionaries"""
    num_layers = global_settings['num_layers']
    configuration = {}

    for i in range(global_settings['num_layers']):
        sample_name = input('Pick sample for layer ' + str(i+1) + ': ')
        # + str(i) to prevent sample settings not being saved because of duplicates, can also be done with ennumerate but I didn't know this at the time
        configuration[sample_name + '_' + str(i)] = settings(type = "sample", file_name = sample_name)

    print(configuration)
    return configuration

global_settings = settings(type = 'global')
sample_settings = pack_sample_settings()

def generate_euclidean_durations():
    """
    Creates a nested dictionary containing durations generated by a euclidean algorithm for every layer
    """

    euclidean_sequence = {}

    for layer_name in sample_settings:


        # Improves readability
        num_notes = sample_settings[layer_name]['num_notes']
        num_pulses = global_settings['num_pulses']
        rotation_amount = sample_settings[layer_name]['rotation_amt']

        duration = int(num_pulses / num_notes)
        remainder = num_pulses - (num_notes * duration)
        duration_sequence = [duration] * num_notes

        # Distributes remainder amongst values stored in duration_sequence
        for j in range(remainder):
            duration_sequence[j] += 1

        rotated_sequence = inp.rotate(duration_sequence, rotation_amount)

        euclidean_sequence[layer_name] = rotated_sequence


    return euclidean_sequence

def get_values_between(**arg): # arg is a dictionary containing the arguments used in this function
    """
    Returns a list of a given length with even steps between two given values

    parameter arg['start']: The starting value of the sequence
    parameter arg['stop']: The end value of the sequence
    parameter arg['num']: The amount of values
    """

    # Sets devault value if 'start' or 'num' argument aren't present in the arg dictionary
    """ Uitleg & Voorbeeld default_values:

    Het is een soort forloop die waardes uit een dictionary leest en op basis van
    de gelezen waardes een bepaald stukje code wel of niet uitvoerd.

        Wat er soortvan staat:
    Als de naam van een parameter die geconfigureerd wordt in 'default_values' NIET
    voorkomt in de dictionary aan parameters die is meegegeven aan de functie.
    Zet dan deze parameter die mist naar de 'default_value'.

    ==================================================================================

    Voorbeeld:

    > Meegegeven parameters zijn: arg['stop'] en arg['num']:
    > default_values zijn: start:0 en num:10

    > for default_setting_name in default_values:
        // de eerste 'default_setting_name' is 'start'
        // de eerste 'input_argument_name' is ook 'start'

        1e loop (loopt dus twee keer want er zijn twee input arguments gegeven (len(arg) = 2)
        > if(not {True for input_argument_name in input_arguments if default_setting_name in input_argument_name}):
            // if start in start -> True
            // if(not True) -> niet de code uitvoeren :)

        2e loop (tweede 'default_setting_name' is 'num',    tweede 'input_argument_name' is 'stop')
            // if num in stop -> False
            // if(not True) -> wel de code uitvoeren >:]

            > arg[default_setting_name] = default_values[default_setting_name]
                // default_setting_name = 'num'
                // dus arg['num'] = default_values['num']
                // default_value van 'num' = 10 dus arg['num'] = 10

    ==================================================================================
    """

    input_arguments = arg.keys()
    default_values = {'start':-10, 'num':10}

    for default_setting_name in default_values:
        if(not {True for input_argument_name in input_arguments if default_setting_name in input_argument_name}):
            arg[default_setting_name] = default_values[default_setting_name]

    list_range = np.linspace(arg['start'], arg['stop'], num=arg['num'], endpoint=True)
    print('start/stop values:',arg['start'],arg['stop'],'\nlist_range', list_range)
    return list_range

def generate_deviations(amount): # arg is a dictionary containing the arguments used in this function

    """
    Returns a nested dictionary for every layer containing the values that will deviate the timestamps
    """

    """ Pseudo code achtig?? vooral veel verwarring ik ga het ook anders doen heb ik besloten :)
    After this I need to figure out how to wrap a timestamp like -8.461538461571429 to something playable.
    Maybe something like:

    dev_timestamp = timestamp + deviation
    cycle_time = num_pulses * quarter_notelength
    cycle_amount = 10

    if dev_timestamp < 0:
        wrapped_dev_timestamp = abs(totalLength - dev_timestamp)

    if dev_timestamp > cycle_time:
        wrapped_dev_timestamp =

    ==================================================================

    K = kick
        original timestamp = 1
        deviated_by = -10

    S = snare
        original timestamp = 4
        deviated_by = 10

    if deviation > 0
        <every cylce deviation decreases by 1>

    if deviation < 0:
        <every cycle deviation increases by 1>


    kick:
    7 0 1 2 3 4 5 6 7 0 1

    snare:
    6 5 4 3 2 1 0 7 6 5 4

        0   1   2   3   4   5   6   7
    1) [_] [_] [_] [_] [_] [_] [S] [K]
    2) [K] [_] [_] [_] [_] [S] [_] [_]
    3) [_] [K] [_] [_] [S] [_] [_] [_]
    4) [_] [_] [K] [S] [_] [_] [_] [_]
    5) [_] [_] [S] [K] [_] [_] [_] [_]
    6) [_] [S] [_] [_] [K] [_] [_] [_]
    7) [S] [_] [_] [_] [_] [K] [_] [_]
    8) [_] [_] [_] [_] [_] [_] [K] [S]
    9) [_] [_] [_] [_] [_] [_] [S] [K]
    10)[K] [_] [_] [_] [_] [S] [_] [_]
    11)[_] [K] [_] [_] [S] [_] [_] [_]


    """

    deviation = {}

    for layer_name in euclidean_durations:
        duration_list = euclidean_durations[layer_name]
        print('\n\nlayer_name: '+layer_name+'\n'+str(euclidean_durations[layer_name]))

        half_duration = sum(duration_list)/2

        range_half_duration = get_values_between(start = -half_duration, stop = (half_duration), num = len(duration_list))
        print(range_half_duration)
        rounded_range = [round(float(value),4) for value in range_half_duration]
        scaled_rounded_range = [value / half_duration for value in rounded_range]

        shuffledFactor = random.sample(scaled_rounded_range, len(scaled_rounded_range)) # random.sample makes a copy, random.shuffle modifies list
        deviation[layer_name] = [amount*shuffledFactor.pop() for value in scaled_rounded_range]

    print('\n\nDeviations:')
    [print(i, deviation[i]) for i in deviation]
    print('\n')
    return deviation

# Collect generated deviations into a dictionary
euclidean_durations = generate_euclidean_durations()
print(euclidean_durations)
deviations = generate_deviations(10)


def duration_to_timestamp():
    """
    Convert durations to timestamps
    """

    timestamp_dictionary = {}

    for layer_name in sample_settings:
        timestamps = []
        durations_current_layer = euclidean_durations[layer_name]
        quarter_note = 60/global_settings['bpm']
        time_duration = [durations_current_layer[i]*quarter_note for i in range(len(durations_current_layer))]

        print('Timedurations '+str(layer_name)+':',time_duration)

        for j in range(len(durations_current_layer)):
            timestamps.append(sum([time_duration[k] for k in range(j)]))

        timestamp_dictionary[layer_name] = timestamps
        sample_settings[layer_name]['time_durations'] = time_duration #kinda a weird way to add time durations to the sample settings dictionary

    print('\n\nTimestamp Dictionary:', timestamp_dictionary,'\n')
    return timestamp_dictionary

timestamps = duration_to_timestamp()

def pack_layers():
    """Collect durations, deviations, volumes, etc. of all layers into one dictionary
    so these values can be used by the player"""
    packed_layers = {}



    # TODO: make packed layers work with player
    # expected order:
    """
    timestamps
    audio_file_name
    time_durations
    channel

    """

    # Maybe make a global setting for max deviation?
    for index, i in enumerate(sample_settings):
        packed_layers[i] = {
            'timestamp': timestamps[i],
            'audio_file_name': sample_settings[i]['sample'],
            'time_durations': sample_settings[i]['time_durations'],
            'duration': euclidean_durations[i],
            'deviation': deviations[i],
            'volume': sample_settings[i]['volume'],
            'channel': index}
        print('\n'+i + '\n\n' + str(packed_layers[i]))

    return packed_layers

# generate a list with durations with 'generate_sequence' for every track and combine them into a dictionary
packed_layers = pack_layers()

# Prints the values in generate_sequences
print()
[print(i, packed_layers[i]) for i in packed_layers]


# TODO: Fix bug with rotation add cycle amt to global settings
"""Discovered a bug with rotation:
my rotate function rotates durations,
so all layers always start at timestamp 0,
might sound kinda boring so look into this maybe"""

# sum(duration_sequence)*quarter_note = cycle_time in seconds in this case 8.5
# cycle_time = 8.5


# sorted_timestamps per layer
"""event_dictionary = {
    'layer_0': {
        'timestamps': [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.5, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0],
        'audio_file_name': 'kick.wav',
        'time_durations': [0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
        'channel': 0},
    'layer_1': {
        'timestamps': [0, 1.0, 2.0, 3.0, 4.5, 6.0, 7.5],
        'audio_file_name': 'snare.wav',
        'time_durations': [1.0, 1.0, 1.0, 1.5, 1.5, 1.5, 1.0],
        'channel': 1},
    'layer_2': {
        'timestamps': [0, 1.0, 2.5, 4.0, 5.5, 6.5, 7.5],
        'audio_file_name': 'hihat.wav',
        'time_durations': [1.0, 1.5, 1.5, 1.5, 1.0, 1.0, 1.0],
        'channel': 2},
    'layer_3': {
        'timestamps': [0, 4.5],
        'audio_file_name': 'perc.wav',
        'time_durations': [4.5, 4.0],
        'channel': 3}}"""

mixer.init()

# creates a channel for every layer
mixer.set_num_channels(len(packed_layers)) # Should be len(sample_settings) when implementing
print('\n\nAmount of layers:',len(packed_layers),'\n')

def sort_by_timestamp(input_list):
    return input_list[0]

def convert_to_events(zip_dict, expected_length): #give expected_length as input

    if(False in [(expected_length == zip_dict[key_name]) for key_name in zip_dict]):
        print('\n\n================ZIP_OWN_DICT================\n\nAll note events in cycle:')

        sorted_values = []

        for index in range(expected_length):
            values = [zip_dict[layer][index] for layer in zip_dict]
            print('Values of index', str(index)+':', values)
            sorted_values.append(values)

        print('\nValues to be sorted:', '\n'+str(sorted_values))
        sorted_values.sort(key=sort_by_timestamp)
        print('\nSorted values:', '\n'+str(sorted_values))
    else:
        print('Something went wrong, not every key has the same amount of values')

    zipped_dict = dict(zip([index for index in range(len(sorted_values))],sorted_values))

    print('\nzipped_dict:','\n'+str(zipped_dict))

    return zipped_dict

def combine(*inputs):
    """Combines all inputs into one list"""

    # print('\ninput is:\n',inputs, '\nType', type(inputs), len(inputs))

    # print('\ncheck if input is a list:\n',inputs[0], '\nType', type(inputs[0]))

    if isinstance(inputs[0],int):
        # print("\ninput is an int and can't be combined:\n\noutput is:\n",inputs[0])
        return list(inputs)

    # print('\ncheck if list in:\n',[[i for i in inputs[j]] for j in range(len(inputs))][0])

    if False in [isinstance(value, list) for value in [[lists
        for lists in inputs[tuple_number]]
            for tuple_number in range(len(inputs))][0]]:

        # print('\nno lists in inputs...\ncheck if inputs are in a tuple:\n',type(inputs),'\n', inputs)
        if isinstance(inputs, tuple):
            inputs = list(inputs)[0]
            # print('\ninput was in tuple,\n remove tuple\n return:', inputs)
            return inputs
        else:
            # print('!!something went wrong!!')
            return inputs

    # print('\nfound at least one list!')

    output = []

    for j in range(len(inputs)):
        for i in inputs[j]:
            output.extend(i)
        # print('\ntemporary output is:\n',type(output),'\n', output)

    # print('\noutput is:\n',type(output),'\n', output)
    return output

def combine_layers():

    # input_dict = event_dictionary -> For readability
    input_dict = packed_layers # TODO: change to dictionary that needs to be combined
    print('\ninput_dict:\n',input_dict, '\n')

    print('Layers:\n',[i
        for i in input_dict], '\n')

    key_dict = [input_dict[j]
        for j in input_dict]
    print('Key_dict:\n',key_dict, '\n')
    # print('Key_dict:\n',[key_dict[i]['timestamps'] for i in range(len(key_dict))], '\n')

    key_names = [name
        for name in key_dict[0]]
    print('Key_names:\n',key_names, '\n')

    # everytime I use list comprehension it puts everything in another list. I do [0] to fix this
    all_values = [[[input_dict[layer][name]
        for layer in input_dict]
        for name in key_names]][0]

    print('\nall_values:\n',all_values,'\n\n',all_values[0])

    key = [i for i in range(len(all_values[0]))]
    all_combined_lengths = {}
    combined_dict = {}
    combined_layer_dict = {}


    for index, name in enumerate(key_names):
        combined_layer_dict[name] = dict(zip(key, all_values[index]))
        combined_dict[name] = combine(list(combined_layer_dict[name].values()))

        print('\ndict values:\n',[combined_layer_dict[name][i] for i in range(len(combined_layer_dict[name]))])
        print('\nlength of current dict:\n',len(combine([combined_layer_dict[name][i] for i in range(len(combined_layer_dict[name]))])))

        all_combined_lengths[name] = len(combine([combined_layer_dict[name][i]
            for i in range(len(combined_layer_dict[name]))]))

    print('\n\ncombined_layer_dict:\n',combined_layer_dict)
    print('\n--->all_combined_lengths:\n',all_combined_lengths)
    print('\n\ncombined_dict:\n',combined_dict)

    # expected number of values in a layer (every layer should be the same length)
    expected_length = max([all_combined_lengths[i]
        for i in all_combined_lengths])
    print('\n\n expected_length:\n',expected_length)

    names_below_expected = [key_name
        for key_name in all_combined_lengths
        if all_combined_lengths[key_name] != expected_length]
    print('\n\n names_below_expected:\n',names_below_expected)

    """ test:
    Assigning a new value to an existing key overwrites the values stored in this key.
    did a test:
    ========================================================================
    >>> dict1 = dict.fromkeys(['a','b','c','d'], [1,2,3,4])
    >>> dict1['a'] = 'test if this works'
    >>> dict1
    {'a': 'test if this works', 'b': [1, 2, 3, 4], 'c': [1, 2, 3, 4], 'd': [1, 2, 3, 4]}
    ========================================================================
    """

    print('------------\n',list(combined_layer_dict[name].keys()))

    """
    length_keyname might not always be at the same index in a list..
    maybe fix later? very low priority
    """
    #keyname to base expected layer lengths off of, needed this for something
    length_keyname = [name
        for name in all_combined_lengths if all_combined_lengths[name] == expected_length][0]
    print('length_keyname\n',length_keyname)

    layer_lengths = [len(length)
        for length in [combined_layer_dict[length_keyname][i]
        for i in range(len(combined_layer_dict[length_keyname]))]]

    print('---->layer_lengths:',layer_lengths)

    # Extends 'combined_dict' Dictionary with the keys that were below the expected amount
    for name in names_below_expected:
        values_to_add = []
        for index, layer in enumerate(layer_lengths):
            values_to_add += [combined_dict[name][index] for number in range(layer_lengths[index])]
        combined_dict[name] = values_to_add

    print('\ncombined_dict with added values:\n',combined_dict)

    return [combined_dict,expected_length]
    # zipped_dictionary = convert_to_events(combined_dict, expected_length)

combined_dictionary = combine_layers()
# index 1 = expected amount of values of each key in the dict
expected_length = combined_dictionary[1]
# index 0 = the combined_dictionary
event = convert_to_events(combined_dictionary[0], expected_length)

print('\n|=------------=(NOTE_EVENTS)=------------=|\n  evnt_num | ts | sample | dur_sec | chan')
[print('|-----------------------------------------|\n',i, event[i]) for i in event]
print()

# player :) finally

# pos stands for playback position
pos = 0
time_zero = time.time()

while pos < expected_length:

    # channel = pygame.mixer.Channel(event[pos][3]) # !!!mixer.find_channel()!!!
    # sample = pygame.mixer.Sound('assets/soundFiles/'+event[pos][1])

    # For readability
    timestamp = event[pos][0]
    sample = mixer.Sound('assets/soundFiles/'+event[pos][1])
    play_time = event[pos][2]
    # maybe just make a whole bunch of channels and let it pick a free one by itsel, at higher bpms soudfiles still overlap
    channel = mixer.Channel(event[pos][3])

    now = time.time() - time_zero

    if(now >= timestamp):
        # print(sound_file,'played at',now)

        channel.play(sample)
        print(timestamp,'|',event[pos][1])
        pos += 1

    time.sleep(0.001)

print()
while channel.get_busy():
    time.sleep(0.001)
else:
    print('\nNo timestamps left -> exit player')

""" Sources
Exit function:              https://www.geeksforgeeks.org/python/python-exit-commands-quit-exit-sys-exit-and-os-_exit/
Find available channel:     https://www.pygame.org/docs/ref/mixer.html#pygame.mixer.find_channel
Run functions in parallel:  https://stackoverflow.com/questions/7207309/how-to-run-functions-in-parallel
.fromkeys dict method:      https://www.geeksforgeeks.org/python/python-dictionary-fromkeys-method/
.extend list method:        https://www.geeksforgeeks.org/python/python-list-extend-method/
isinstance function:        https://www.w3schools.com/python/ref_func_isinstance.asp
values between range:       https://stackoverflow.com/questions/64338441/how-to-get-the-values-between-a-range-in-python#64338552
multiply list:              https://www.geeksforgeeks.org/python/sum-function-python/
devide list:                https://www.geeksforgeeks.org/python/divide-all-elements-of-a-list-by-a-number-in-python/
list comprehension:         https://www.geeksforgeeks.org/python/python-list-comprehension/
check dict for item:        https://www.geeksforgeeks.org/python/check-if-dictionary-value-contains-certain-string-with-python/
dict comprehension:         https://www.geeksforgeeks.org/python/python-dictionary-comprehension
numer odd or even?:         https://stackoverflow.com/questions/21837208/check-if-a-number-is-odd-or-even-in-python#21837247
shuffle list:               https://www.geeksforgeeks.org/python/python-ways-to-shuffle-a-list/
random:                     https://www.w3schools.com/python/ref_module_random.asp
random.sample:              https://www.w3schools.com/python/ref_random_sample.asp
"""
