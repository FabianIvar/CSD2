# mostly the same as euclid_dictionary.py but with user deviation implemented

from list_transform import rotate
import random
import inp_v2 as inp
import numpy as np
from inp_v2 import validateType as check

""" settings function with user input certain values need to be constrained
def settings(**set):

    # Returns global_settings and sample_settings stored in a dictionary
    #
    # Parameter set['file_name']: The name of the sample to configure and return settings of
    # Parameter set['type']: The type of setting to configure and return
            # Options: "global", "sample"



        case 'global':
            global_config = {
                "num_layers": inp.constrain(check(input("Number of layers (1-4): "),'int'), 0, 4),
                "num_pulses": check(input("Number of pulses: "),'int'),
                "bpm": inp.constrain(check(input("Beats per minute: "),'int'), 0, 512),
                "state": 'configured'}
            return global_config

        case 'sample':
            if global_settings['state'] != 'configured':
                print("global settings are not yet configured")
            else:
                sample_config = {
                    "sample": set['file_name'] + '.wav',
                    "num_pulses": global_settings['num_pulses'],
                    "num_notes": check(input("Number of notes: "),'int'),
                    "volume": inp.constrain(check(input("Gain (value between 0-1): "),'float'), 0, 1),
                    "rotation_amt": check(input("amt to rotate:"),'int')}
                sample_config.update({'num_notes': constrain(sample_config['num_notes'], 0, global_settings['num_pulses'])})
                return sample_config"""

def settings(**set):
    """
    Returns global_settings and sample_settings stored in a dictionary

    Parameter set['file_name']: The name of the sample to configure and return settings of
    Parameter set['type']: The type of setting to configure and return
            Options: "global", "sample"

    """
    match set['type']:

        case 'global':
            global_config = {
                "num_layers": inp.constrain(check(4,'int'), 0, 4),
                "num_pulses": check(random.randint(1,20),'int'),  # cant be zero because division by zero
                "bpm": inp.constrain(check(120,'int'), 0, 512),
                "state": 'configured'}
            return global_config

        case 'sample':
            if global_settings['state'] != 'configured':
                print("global settings are not yet configured")
            else:
                sample_config = {
                    "sample": set['file_name'] + '.wav',
                    "num_pulses": global_settings['num_pulses'],
                    "num_notes": check(random.randint(1,15),'int'), #can't be 0 because division by zero
                    "volume": inp.constrain(check(1,'float'), 0, 1),
                    "rotation_amt": check(random.randint(1,10),'int')}
                sample_config.update({'num_notes': inp.constrain(sample_config['num_notes'], 0, global_settings['num_pulses'])})
                return sample_config

def pack_sample_settings():
    """Starts sample settings configuration and saves the settings of each sample in nested dictionaries"""
    num_layers = global_settings['num_layers']
    configuration = {}

    for i in range(global_settings['num_layers']):
        """->"""# sample_name = input('Pick sample for layer ' + str(i+1) + ': ')
        # + str(i) to prevent sample settings not being saved because of duplicates, can also be done with ennumerate but I didn't know this at the time

        """->"""#configuration[sample_name + '_' + str(i)] = settings(type = "sample", file_name = sample_name)
        configuration['sample_name' + '_' + str(i)] = settings(type = "sample", file_name = 'sample_name')
    print(configuration)
    return configuration

global_settings = settings(type = 'global')
sample_settings = pack_sample_settings()

def generate_euclidean_durations():
    """
    Creates a nested dictionary containing durations generated by a euclidean algorithm for every layer
    """

    euclidean_sequence = {}

    for layer_name in sample_settings:


        # Improves readability
        num_notes = sample_settings[layer_name]['num_notes']
        num_pulses = global_settings['num_pulses']
        rotation_amount = sample_settings[layer_name]['rotation_amt']

        duration = int(num_pulses / num_notes)
        remainder = num_pulses - (num_notes * duration)
        duration_sequence = [duration] * num_notes

        # Distributes remainder amongst values stored in duration_sequence
        for j in range(remainder):
            duration_sequence[j] += 1

        rotated_sequence = inp.rotate(duration_sequence, rotation_amount)

        euclidean_sequence[layer_name] = rotated_sequence

    return euclidean_sequence

def get_values_between(**arg): # arg is a dictionary containing the arguments used in this function
    """
    Returns a list of a given length with even steps between two given values

    parameter arg['start']: The starting value of the sequence
    parameter arg['stop']: The end value of the sequence
    parameter arg['num']: The amount of values
    """

    # Sets devault value if 'start' or 'num' argument aren't present in the arg dictionary
    """ Uitleg & Voorbeeld default_values:

    Het is een soort forloop die waardes uit een dictionary leest en op basis van
    de gelezen waardes een bepaald stukje code wel of niet uitvoerd.

        Wat er soortvan staat:
    Als de naam van een parameter die geconfigureerd wordt in 'default_values' NIET
    voorkomt in de dictionary aan parameters die is meegegeven aan de functie.
    Zet dan deze parameter die mist naar de 'default_value'.

    ==================================================================================

    Voorbeeld:

    > Meegegeven parameters zijn: arg['stop'] en arg['num']:
    > default_values zijn: start:0 en num:10

    > for default_setting_name in default_values:
        // de eerste 'default_setting_name' is 'start'
        // de eerste 'input_argument_name' is ook 'start'

        1e loop (loopt dus twee keer want er zijn twee input arguments gegeven (len(arg) = 2)
        > if(not {True for input_argument_name in input_arguments if default_setting_name in input_argument_name}):
            // if start in start -> True
            // if(not True) -> niet de code uitvoeren :)

        2e loop (tweede 'default_setting_name' is 'num',    tweede 'input_argument_name' is 'stop')
            // if num in stop -> False
            // if(not True) -> wel de code uitvoeren >:]

            > arg[default_setting_name] = default_values[default_setting_name]
                // default_setting_name = 'num'
                // dus arg['num'] = default_values['num']
                // default_value van 'num' = 10 dus arg['num'] = 10

    ==================================================================================
    """

    input_arguments = arg.keys()
    default_values = {'start':-10, 'num':10}

    for default_setting_name in default_values:
        if(not {True for input_argument_name in input_arguments if default_setting_name in input_argument_name}):
            arg[default_setting_name] = default_values[default_setting_name]

    list_range = np.linspace(arg['start'], arg['stop'], num=arg['num'], endpoint=True)
    print('start/stop values:',arg['start'],arg['stop'],'\nlist_range', list_range)
    return list_range

def generate_deviations(amount): # arg is a dictionary containing the arguments used in this function

    """
    Returns a nested dictionary for every layer containing the values that will deviate the timestamps
    """

    """ Pseudo code achtig?? vooral veel verwarring ik ga het ook anders doen heb ik besloten :)
    After this I need to figure out how to wrap a timestamp like -8.461538461571429 to something playable.
    Maybe something like:

    dev_timestamp = timestamp + deviation
    cycle_time = num_pulses * quarter_notelength
    cycle_amount = 10

    if dev_timestamp < 0:
        wrapped_dev_timestamp = abs(totalLength - dev_timestamp)

    if dev_timestamp > cycle_time:
        wrapped_dev_timestamp =

    ==================================================================

    K = kick
        original timestamp = 1
        deviated_by = -10

    S = snare
        original timestamp = 4
        deviated_by = 10

    if deviation > 0
        <every cylce deviation decreases by 1>

    if deviation < 0:
        <every cycle deviation increases by 1>


    kick:
    7 0 1 2 3 4 5 6 7 0 1

    snare:
    6 5 4 3 2 1 0 7 6 5 4

        0   1   2   3   4   5   6   7
    1) [_] [_] [_] [_] [_] [_] [S] [K]
    2) [K] [_] [_] [_] [_] [S] [_] [_]
    3) [_] [K] [_] [_] [S] [_] [_] [_]
    4) [_] [_] [K] [S] [_] [_] [_] [_]
    5) [_] [_] [S] [K] [_] [_] [_] [_]
    6) [_] [S] [_] [_] [K] [_] [_] [_]
    7) [S] [_] [_] [_] [_] [K] [_] [_]
    8) [_] [_] [_] [_] [_] [_] [K] [S]
    9) [_] [_] [_] [_] [_] [_] [S] [K]
    10)[K] [_] [_] [_] [_] [S] [_] [_]
    11)[_] [K] [_] [_] [S] [_] [_] [_]


    """

    deviation = {}

    for layer_name in euclidean_durations:
        duration_list = euclidean_durations[layer_name]
        print('\n\nlayer_name: '+layer_name+'\n'+str(euclidean_durations[layer_name]))

        half_duration = sum(duration_list)/2

        range_half_duration = get_values_between(start = -half_duration, stop = (half_duration), num = len(duration_list))
        print(range_half_duration)
        rounded_range = [round(float(value),4) for value in range_half_duration]
        scaled_rounded_range = [value / half_duration for value in rounded_range]

        shuffledFactor = random.sample(scaled_rounded_range, len(scaled_rounded_range)) # random.sample makes a copy, random.shuffle modifies list
        deviation[layer_name] = [amount*shuffledFactor.pop() for value in scaled_rounded_range]

    print('\n\nDeviations:')
    [print(i, deviation[i]) for i in deviation]
    print('\n')
    return deviation

# Collect generated deviations into a dictionary
euclidean_durations = generate_euclidean_durations()
deviations = generate_deviations(10)


def duration_to_timestamp():
    """
    Convert durations to timestamps
    """

    timestamp_dictionary = {}

    for layer_name in sample_settings:
        timestamps = []
        durations_current_layer = euclidean_durations[layer_name]
        quarter_note = 60/global_settings['bpm']
        time_duration = [durations_current_layer[i]*quarter_note for i in range(len(durations_current_layer))]

        print('Timedurations '+str(layer_name)+':',time_duration)

        for j in range(len(durations_current_layer)):
            timestamps.append(sum([time_duration[k] for k in range(j)]))

        timestamp_dictionary[layer_name] = timestamps
        # packed_layers[i]['timestamp'] = duration_to_timestamp(packed_layers[i]['duration'])

    print('\n\nTimestamp Dictionary:', timestamp_dictionary,'\n')
    return timestamp_dictionary

timestamps = duration_to_timestamp()

def pack_layers():
    """Collect durations, deviations, volumes, etc. of all layers into one dictionary"""
    packed_layers = {}

    # Maybe make a global setting for max deviation?
    for i in sample_settings:
        packed_layers[i] = {
            'duration': euclidean_durations[i],
            'timestamp': timestamps[i],
            'deviation': deviations[i],
            'volume': sample_settings[i]['volume']}
        print('\n'+i + '\n\n' + str(packed_layers[i]))

    return packed_layers

# generate a list with durations with 'generate_sequence' for every track and combine them into a dictionary
packed_layers = pack_layers()

# Prints the values in generate_sequences
print()
[print(i, packed_layers[i]) for i in packed_layers]

'''Sources
values between range:   https://stackoverflow.com/questions/64338441/how-to-get-the-values-between-a-range-in-python#64338552
multiply list:          https://www.geeksforgeeks.org/python/sum-function-python/
devide list:            https://www.geeksforgeeks.org/python/divide-all-elements-of-a-list-by-a-number-in-python/
list comprehension:     https://www.geeksforgeeks.org/python/python-list-comprehension/
check dict for item:    https://www.geeksforgeeks.org/python/check-if-dictionary-value-contains-certain-string-with-python/
dict comprehension:     https://www.geeksforgeeks.org/python/python-dictionary-comprehension
numer odd or even?:     https://stackoverflow.com/questions/21837208/check-if-a-number-is-odd-or-even-in-python#21837247
shuffle list:           https://www.geeksforgeeks.org/python/python-ways-to-shuffle-a-list/
random:                 https://www.w3schools.com/python/ref_module_random.asp
random.sample:          https://www.w3schools.com/python/ref_random_sample.asp
'''

# /Volumes/T7/Documenten/Git/CSD2/python_basics/exercises/euclid_deviationFactor.py
